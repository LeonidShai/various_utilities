# Golang questions

### 1 Что такое interface?
interface - это штука, которая определяет поведение. Он определяет и описывает конкретные методы, которые должны быть у какого-то другого типа.
```
type iface struct {
    tab  *itab
    data unsafe.Pointer
}
```
tab — это указатель на Interface Table или itable — структуру, которая хранит некоторые метаданные о типе и список методов, используемых для удовлетворения интерфейса.
data — указывает на фактическую переменную с конкретным (статическим) типом.

itable - таблица будет уникальна для каждой пары интерфейс-статический тип, то просчитывать её на этапе компиляции (early binding) будет нерационально и неэффективно.

Вместо этого, компилятор генерирует метаданные для каждого статического типа, в которых, помимо прочего, хранится список методов, реализованных для данного типа. Аналогично генерируются метаданные со списком методов для каждого интерфейса. Теперь, во время исполнения программы, runtime Go может вычислить itable на лету (late binding) для каждой конкретной пары. Этот itable кешируется, поэтому просчёт происходит только один раз.

Поскольку у пустого интерфейса нет никаких методов, то и itable для него просчитывать и хранить не нужно — достаточно только метаинформации о статическом типе.

Интерфейс создается потребителем (consumer), а не продюсером (producer).


### 2 Как устроена map?
```
// A header for a Go map.
type hmap struct {
	count     int // размер мапы. используется функцией len()
	flags     uint8
	B         uint8  // log_2 количества бакетов. Для 8 бакетов B=3, для 16 B=4 и так далее.
	noverflow uint16 // примерное число переполненных бакетов
	hash0     uint32 // seed для хэш-функции, генерируется при создании мапы. нужен для рандомизации хэш-функции

	buckets    unsafe.Pointer // ссылка на массив из 2^B бакетов; nil, если count==0
	oldbuckets unsafe.Pointer // ссылка на массив предыдущих бакетов. в процессе роста мапы здесь будет массив старых бакетов, откуда потихоньку будут переноситься значения в новые бакеты.
	nevacuate  uintptr        // количество "эвакуированных" бакетов.

	extra *mapextra // опциональные поля
}

// A bucket for a Go map.
type bmap struct {
	tophash [bucketCnt]uint8 // массив tophash
	// После массива tophash идет массив размера bucketCnt ключей и массив размера bucketCnt элементов.
}
```

Упрощенный принцип работы hashmap:
- Передаем ключ в хэш-функцию. Получаем uint64 - 18002143618149980261;
- Вычисляем маску для наших бакетов. Она равна n-1, где n - количество бакетов. В примере 4 бакета, а маска равна 3;
- Вычисляем номер бакета, в котором сохраним наше значение. Для этого используем битовое "и": hash & mask == 18002143618149980261 & 3 == 01 & 11(отбросили нули) = 01, что рано 1 в десятичной системе счисления;
- Идем в бакет по индексу 1 и перебором проверяем массив на наличие нашего ключа. Если находим совпадение по ключу, то перезаписываем значение, иначе добавляем в первое свободное место;

Интересности реализации:
- В качестве ключа можно использовать любой тип данных для которого определена операция сравнения. Например, можно использовать структуру с тем же условием для всех ее полей;
- При отсутствии элемента возвращается нулевое значение для типа. Вторым параметром можно получить флаг наличия элемента по ключу;
- Нельзя получить адрес элемента. Потому что при росте мапы оно переедет в другой бакет и адрес у него, соответственно, поменяется;
- Мапа не безопасна для конкурентного использования. Для этого можно использовать обертку из sync.Map или мьютекс;
- Порядок итерации не сохраняется. При каждой новой итерации мапы последовательность возвращаемых элементов может отличаться. Под капотом каждый раз выбирается рандомный бакет, с которого начинается итерация. Для сохранения нужного порядка придется сохранять ключи в отдельном массиве и итерироваться по нему;
- При каждом создании мапы генерируется seed для рандомизации хэш-функции. Это сделано для безопасности, так как зная хэш-функцию можно подобрать такие ключи, что все значения попадут в один бакет и мы получим линейную скорость поиска;
- При коллизиях используется стратегия сlosed addressing. Мы перебираем все ячейки бакета (их 8) и ищем первое свободное место;
- OverloadFactor равен 6.5 (~81% заполненности бакетов). Когда бакеты в среднем заполнены больше чем на 6.5 элементов, тригерится рост мапы, и все элементы перемещаются в новые бакеты, которых создается в два раза больше.
- При росте элементы переносятся в новые бакеты постепенно, а не все сразу;
- Если в каждом «ведре» в среднем более 6,5 элементов, происходит увеличение массива buckets. При этом выделяется массив в 2 раза больше, а старые данные копируются в него маленькими порциями каждые вставку или удаление, чтобы не создавать очень крупные задержки. Поэтому все операции будут чуть медленнее в процессе эвакуации данных (при поиске тоже, нам же приходится искать в двух местах). После успешной эвакуации начинают использоваться новые данные.

Интересное про хэшмап:
- Хэш-функция(Hash function). Под ней понимают функцию, которая принимает значение (ключ) неопределенного размера и возвращает значение фиксированной длины. В случае c Go она возвращает uint64. Одно из главных свойств - стабильность. Для одного и того же переданного значения она должна возвращать один и тот же результат;

- Бакет(Bucket/Slot). Так называемая структура данных, в которой хранятся ключи и значения в мапе. В некоторых реализациях hashmap в одном бакете хранится одно значение, а в других - несколько. Например, в Go данные внутри бакета хранятся в массиве, и в одном бакете может быть до восьми элементов;

- Коллизия (Collision). Так как хэш-функция не идеальна, передав в нее два разных значения мы можем получить один и тот же результат. В случае с бакетами нам нужно два разных значения положить в один и тот же бакет. Это называется коллизией. Для реализации hashmap необходимо иметь алгоритм их разрешения. Существует несколько таких алгоритмов (стратегий):

-- Closed addressing. Храним элементы с одинаковым хэшем с помощью дополнительных структур данных, таких как: связный список, двоичное дерево, массив и др. Используется в следующих языках: Go, Java, Scala;

-- Open addressing. В бакете хранится только одно значение. При возникновении коллизии выбирается следующий свободный бакет по какой-либо формуле. Такая стратегия используется в Python, Ruby, Rust, C++ и др;

-- Perfect hashing. Выбирается такая хэш-функция, при которой не будет коллизий. Подбирается для статичного, заранее известного набора ключей.

- Фактор заполненности мапы (Overload factor). Это число (порог), превысив которое считается, что нужно увеличить количество бакетов (обычно вдвое) для сохранения константной скорости O(1)

### компиляция
1 Lexer (Лексический анализатор) — это первый этап компиляции, где ваши исходники превращаются в понятный для компьютера набор токенов.
Как только лексер натыкается на известные ему конструкции (ключевые слова, операторы, идентификаторы и т.д.), он вырезает их из текста и превращает в токены. Каждый токен — это пара: тип токена и его значение.

2 Parser (Синтаксический анализатор) — это компонент компилятора, который берет линейную последовательность токенов от лексера и превращает ее в дерево, отражающее структуру кода. В Go, как и во многих языках, парсер строит AST, но делает это со своими особенностями. Парсер начинает свою работу с получения токенов от лексера. Эти токены содержат информацию о типе элемента (например, идентификатор, ключевое слово) и его значении. Парсер анализирует последовательность токенов и по правилам синтаксиса Go строит AST. Каждый узел в AST соответствует конструкции в исходном коде, будь то оператор, выражение, объявление и так далее.

3 Type checker (Проверка типов) — это компонент компилятора Go, который удостоверяется, что все операции в вашем коде типологически корректны. Он проверяет, что вы не пытаетесь выполнить операции, которые не имеют смысла, например, сложить строку и число или вызвать метод на переменной неподходящего типа.

4 Optimizer (Оптимизатор) – это набор алгоритмов, которые анализируют и трансформируют код для улучшения его производительности и уменьшения размера. Если часть кода никогда не выполняется, оптимизатор уберет ее. Когда маленькие функции встраиваются прямо в место их вызова, это уменьшает накладные расходы на вызов функций. Если компилятор видит выражение, значение которого он может вычислить на этапе компиляции (например, 2 + 2), он заменит его на результат (4). Оптимизатор пытается использовать процессорные регистры наиболее эффективно, чтобы минимизировать медленные обращения к памяти.

5 Code generator (Генератор кода) — это фаза в компиляторе Go, которая берет оптимизированное AST и превращает его в инструкции, понятные процессору вашего компьютера. Каждая операция в коде соответствует определенной инструкции или набору инструкций на уровне машины:
- Определение целевой архитектуры: Прежде всего, генератор кода должен знать, под какую архитектуру он компилирует код — это может быть x86, ARM, MIPS и так далее. Каждая архитектура имеет свой набор инструкций.
- Анализ операций: Для каждой операции в AST (например, сложение, вызов функции, доступ к памяти) генератор кода определяет, какая машинная инструкция или последовательность инструкций соответствует данной операции.

### Garbage collection
Go использует алгоритм три-цветной маркировки для GC. В этом алгоритме объекты в памяти маркируются тремя цветами:
- Белый: Объекты, которые еще не были достигнуты.
- Серый: Объекты, которые были достигнуты, но их дочерние объекты еще не обработаны.
- Черный: Объекты, которые и их дочерние объекты были полностью обработаны.
В начале процесса все объекты белые. По мере продвижения алгоритма, объекты переходят от белого к серому и, наконец, к черному. В конце процесса все достижимые объекты будут черными, а недостижимые (белые) могут быть собраны.

Компилятор Go помогает в процессе GC на нескольких уровнях:
На этапе компиляции проводится анализ "убегания" переменных. Если компилятор определяет, что переменная не убегает из своей области видимости (то есть не становится доступной вне своей функции), то она может быть выделена на стеке, а не в куче, уменьшая нагрузку на GC.
Компилятор вставляет специальный код, который помогает среде выполнения отслеживать ссылки на объекты и управлять жизненным циклом объектов.

Переменная среды GOGC позволяет настроить частоту сбора мусора, указывая, на сколько процентов должна увеличиться куча перед следующим сбором мусора.


### Принципы SOLID
S – Single Responsibility (Принцип единственной ответственности)
Каждый класс должен отвечать только за одну операцию.

O — Open-Closed (Принцип открытости-закрытости)
Классы должны  быть  открыты для расширения, но закрыты для модификации.

L — Liskov Substitution (Принцип подстановки Барбары Лисков)
Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы.

I — Interface Segregation (Принцип разделения интерфейсов)
Не следует ставить клиент в зависимость от методов, которые он не использует.

D — Dependency Inversion (Принцип инверсии зависимостей)
Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

### Что такое gorutine?
Горутины — это легковесные потоки, которые реализуют конкурентное программирование в Go. Их называют легковесными потоками, потому что они управляются рантаймом языка, а не операционной системой. Стоимость переключения контекста и расход памяти намного ниже, чем у потоков ОС.
Расширяемый стек от 2-х Кб

Горутины — это дальнейшее усовершенствование концепции потока, а если сказать проще, то это функции, способные работать параллельно с другими такими же функциями в одном адресном пространстве. Причем их настолько хорошо усовершенствовали, что они стали отдельной сущностью. В многопроцессорной среде создание и обслуживание процесса сильно зависят от базовой операционной системы. Процессы потребляют ресурсы операционки и не делят их между узлами. Потоки, хотя и легче, чем процессы, из-за совместного использования ресурсов (между одноранговыми потоками), требуют большого размера стека — почти 1 МБ. Причем стек нужно умножать на количество потоков.

Кроме того, их переключение требует восстановления регистров, таких как программные счетчики, указатели стека, регистры с плавающей запятой и т. д. Из-за этого стоимость обслуживания процесса или потока довольно высока. Кроме того, в случаях, когда данные совместно используются одноранговыми узлами, возникают дополнительные затраты на синхронизацию данных. Хотя накладные расходы на переключение между задачами максимально оптимизированы, постановка новых задач по-прежнему требует больше ресурсов. Иногда это сильно снижает производительность приложения, даже если потоки обозначены как легковесные.

Преимущество горутин в том, что они не зависят от базовой операционной системы, а скорее, существуют в виртуальном пространстве среды выполнения Go. В результате любая оптимизация горутины меньше зависит от платформы, на которой она работает. Они начинают работать с начальной емкости стека размером всего 2-4 КБ и наряду с каналами поддерживают модели параллелизма взаимодействующих последовательных процессов (CSP), где значения передаются между независимыми действиями. Эти действия, как вы уже догадались, называются горутинами.